<!-- Generated with EZOut 2.0.6: Install-Module EZOut or https://github.com/StartAutomating/EZOut -->
<Types>
  <Type>
    <Name>PSJekyll</Name>
    <Members>
      <ScriptMethod>
        <Name>FormatMarkdown</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Formats an object as Markdown
.DESCRIPTION
    Formats an object as Markdown, with many options to work with
.EXAMPLE
    Format-Markdown -ScriptBlock {
        Get-Process
    }
.EXAMPLE
        1..6 | Format-Markdown  -HeadingSize { $_ }
#&gt;
param(            
[Parameter(ValueFromPipeline,ValueFromPipelineByPropertyName)]
[PSObject]
$InputObject,

# If set, will treat the -InputObject as a paragraph.
# This is the default for strings, booleans, numbers, and other primitive types.
[Parameter(ValueFromPipelineByPropertyName)]
[switch]
$MarkdownParagraph,

# If set, will generate a markdown table.
[Parameter(ValueFromPipelineByPropertyName)]
[switch]
$MarkdownTable,

# If provided, will align columnns in a markdown table.    
[Parameter(ValueFromPipelineByPropertyName)]
[ValidateSet("Left","Right","Center", "")]
[string[]]
$MarkdownTableAlignment,

# An array of properties.  Providing this implies -MarkdownTable
[Parameter(ValueFromPipelineByPropertyName)]
[PSObject[]]
$Property,

# A heading.
# If provided without -HeadingSize, -HeadingSize will default to 2.
# If provided with -InputObject, -Heading will take priority.
[Parameter(ValueFromPipelineByPropertyName)]    
[string]
$Heading,

# The heading size (1-6)
# If provided without -Heading, the -InputObject will be considered to be a heading.
[Parameter(ValueFromPipelineByPropertyName)]
[ValidateRange(1,6)]
[int]
$HeadingSize,

# If set, will create a link.  The -InputObject will be used as the link content    
[Parameter(ValueFromPipelineByPropertyName)]
[Alias('Hyperlink', 'Href')]
[string]
$Link,

# If set, will create an image link.  The -Inputobject will be used as the link content.
[Parameter(ValueFromPipelineByPropertyName)]
[string]
$ImageLink,

# If set, will generate a bullet point list.
[Parameter(ValueFromPipelineByPropertyName)]
[Alias('BulletpointList')]
[switch]
$BulletPoint,

# If set, bullet or numbered list items will have a checkbox.
# Each piped -InputObject will be an additional list item.
[Parameter(ValueFromPipelineByPropertyName)]
[switch]
$Checkbox,

# If set, bullet or numbered list items will be checked.
[Parameter(ValueFromPipelineByPropertyName)]
[switch]
$Checked,

# If set, will generate a numbered list.
# Each piped -InputObject will be an additional list item.
[Parameter(ValueFromPipelineByPropertyName)]
[switch]
$NumberedList,

# If set, will generate a block quote.
# Each line of the -InputObject will be block quoted.
[Parameter(ValueFromPipelineByPropertyName)]
[switch]
$BlockQuote,

# If set, will generate a block quote of a particular depth.
# Each line of the -InputObject will be block quoted.
[Parameter(ValueFromPipelineByPropertyName)]
[ValidateRange(1,3)]
[int]
$BlockQuoteDepth,
    
# If provided, will create a markdown numbered list with this particular item as the number.
[Parameter(ValueFromPipelineByPropertyName)]
[int]
$Number,

# If set, will generate a horizontal rule.  
# If other parameters are provided, the horiztonal rule will be placed after.
[Parameter(ValueFromPipelineByPropertyName)]
[switch]
$HorizontalRule,

# If set, will output the -InputObject as a Markdown code block
[Parameter(ValueFromPipelineByPropertyName)]
[switch]
$Code,

# If set, will output the -InputObject as a Markdown code block, with a given language
# If the -InputObject is a ScriptBlock, -CodeLanguage will be set to PowerShell.
[Parameter(ValueFromPipelineByPropertyName)]
[string]
$CodeLanguage,

# If provided, will output a script block as a Markdown code block.
[Parameter(ValueFromPipelineByPropertyName)]
[ScriptBlock]
$ScriptBlock
)

begin {
    $numberedListCounter = 0
    $IsFirst = $true
    filter LinkInput {
        $in = $_
        if ($ImageLink) {
            "![$in]($imageLink)"
        } elseif ($link) {
            "[$in]($link)"
        } else {
            "$in"
        }
    }

    $markdownLines = @()
}

process {
    
    if ($ScriptBlock -or $inputObject -is [scriptblock]) {  # If a -ScriptBlock was provided
        $CodeLanguage = 'PowerShell' # use PowerShell as a Code Language.
    }

    # If a -HeadingSize or a -Heading were provided, render a heading.
    if ($HeadingSize -or $Heading) 
    {  
        if (-not $HeadingSize) { $HeadingSize = 2} # If the -HeadingSize was not set, set it to 2.
        $headingContent = "$(if ($Heading) { $Heading} else { $inputObject | LinkInput})"
        $markdownLines += 
            if ($HeadingSize -eq 1) {                
                $headingContent
                '=' * [Math]::Max($headingContent.Length, 3)
            }
            elseif ($HeadingSize -eq 2) {
                $headingContent
                '-' * [Math]::Max($headingContent.Length, 3)
            }
            else  {
                ("#"*$HeadingSize) + " $headingContent" # Output the -Heading or the -InputObject.
            }
    }
    # If -Code or -CodeLanguage was provided, render a Markdown code block.
    elseif ($Code -or $CodeLanguage)
    { 
        # If the -InputObject was a [ScriptBlock] or there is a -ScriptBlock 
        if ($InputObject -is [scriptblock] -or $ScriptBlock) {
            $CodeLanguage  = 'PowerShell' # set the code language to PowerShell.
        }
        $markdownLines += (
            '```' + # Start the code fence,
                $(if ($CodeLanguage) { $CodeLanguage}) + # add the language,
                [Environment]::newline + # then a newline,
                $(
                    $codeContent = $(if ($ScriptBlock) { "$scriptBlock" } else { $inputObject | LinkInput})  # then the -ScriptBlock or -InputObject
                    $codeContent
                ) +
                [Environment]::newline + # then a newline
            '```' # then close the code fence.
        )
    }
    # If -BulletPoint was passed, render a Bullet Point list.
    elseif ($BulletPoint) 
    { 
        $markdownLines += "*$(if ($Checkbox) { "[$(if ($Checked) {"x"} else {" "})]"}) $($inputObject | LinkInput)"
    }
    # If -NumberedList was passed, render a numbered list.
    elseif ($NumberedList -or $Number) 
    {
        $numberedListCounter++ # Increment the counter
        $markdownLines += "$(if ($number) { $number } else {$numberedListCounter}).$(if ($Checkbox) {" [$(if ($Checked) {"x"} else {" "})]"}) $($inputObject | LinkInput)"
    }
    elseif ($BlockQuote -or $BlockQuoteDepth) {
        if (-not $BlockQuoteDepth) { $BlockQuoteDepth = 1 }
        $markdownLines += ("&gt;" * $BlockQuoteDepth ) + ' ' + (
            "$inputObject" -split '(?&gt;\r\n|\n)' -join (
                [Environment]::NewLine + ("&gt;" * $BlockQuoteDepth) + ' '
            )
        )
    }
    # Otherwise, we have to determine if -InputObject should be a -MarkdownTable or a -MarkdownParagraph.
    else
    {
        # If the input is a primitive type or a string, it should be a markdown paragraph
        if (($inputObject.GetType -and $inputObject.GetType().IsPrimitive) -or 
            $inputObject -is [string]) {
            $MarkdownParagraph = $true
        }
        # If it is a dictionary, it should be a markdown table.
        elseif ($inputObject -is [Collections.IDictionary]) 
        {
            $MarkdownTable = $true
        }
        # If the input is an array, apply the same logic:
        elseif ($inputObject -is [Object[]] -or $InputObject -is [PSObject[]]) {
            $allPrimitives = 1
            # if the array was all primitives or strings                
            foreach ($in in $InputObject) {
                $allPrimitives = $allPrimitives -band (
                    ($in.GetType -and $in.GetType().IsPrimitive) -or $in -is [string]
                )
            }
            if ($allPrimitives) { # output as a paragraph.
                $MarkdownParagraph = $true
            } else {
                $MarkdownTable = $true
            }
        }
        # If we're still not sure, output as a table.                     
        else {
            $MarkdownTable = $true
        }
    }

    if ($MarkdownParagraph) {
        # If we're outputting as a paragraph, add the input and link it if needed.
        $markdownLines += $inputObject | LinkInput
    } elseif ($MarkdownTable) {
        # If we're rendering a table, we need to go row-by-row.
        foreach ($in in $InputObject) {
            $propertyList = @(
                # we first need to get a list of properties.
                # If there was a -Property parameter provided, use it.
                if ($Property) {
                    foreach ($prop in $Property) {
                        if ($prop -is [string]) { # Strings in -Property should be taken as property names
                            $prop
                        } elseif ($prop.Name -and $prop.Expression -and $prop.Expression -is [scriptblock]) {
                            # and anything with a name and expression script block will run the expression script block.
                            $_ = $psItem = $in
                            @{name=$prop.Name;Value = . $prop.Expression}
                        }
                    }
                } 
                # Otherwise, if the input was a dictionary
                elseif ($in -is [Collections.IDictionary]) 
                {
                    foreach ($k in $in.Keys) { # take all keys from the dictionary
                        if ($MyInvocation.MyCommand.Parameters[$k]) { continue } # that are not parameters of this function.
                        $k
                    }                        
                }
                # Otherwise, walk over all properties on the object
                else {
                    foreach ($psProp in $In.psobject.properties) {
                        # and skip any properties that are parameters of this function.
                        if ($psProp.Name -notin $MyInvocation.MyCommand.Parameters.Keys) {
                            $psProp
                        }
                    }
                }
            )

            # If we're rendering the first row of a table
            if ($IsFirst) {
                # Create the header
                $markdownLines +=
                    '|' + (@(foreach ($prop in $propertyList) {
                        if ($prop -is [string]) {
                            $prop
                        } else {
                            $prop.Name
                        }
                    }) -replace ([Environment]::newline), '&lt;br/&gt;' -replace '\|', '\|' -join '|') + '|'
                # Then create the alignment row.
                $markdownLines +=
                    '|' + $(
                        $columnNumber =0 
                        @(
                            foreach ($prop in $propertyList) {
                                $colLength = 
                                    if ($prop -is [string]) {
                                        $prop.Length
                                    } else {
                                        $prop.Name.Length
                                    }
                                if ($MarkdownTableAlignment) {
                                    if ($MarkdownTableAlignment[$columnNumber] -eq 'Left') {
                                        ':' + ("-" * ([Math]::Max($colLength,2) - 1))
                                    }
                                    elseif ($MarkdownTableAlignment[$columnNumber] -eq 'Right') {
                                        ("-" * ([Math]::Max($colLength,2) - 1)) + ':'
                                    }
                                    elseif ($MarkdownTableAlignment[$columnNumber] -eq 'Center') {
                                        ':' + ("-" * ([Math]::max($colLength, 3) - 2)) + ':'
                                    } else {
                                        "-" * $colLength
                                    }
                                } else {
                                    "-" * $colLength
                                }
                                
                                $columnNumber++
                            }
                        ) -replace ([Environment]::newline), '&lt;br/&gt;' -replace '\|', '\|' -join '|') + '|'                    
                $IsFirst = $false
            }
            
            # Now we create the row for this object.

            $markdownLine = '|' + (
                @(
                    foreach ($prop in $propertyList) {
                        if ($prop -is [string]) {
                            $in.$prop | LinkInput
                        } else {
                            $prop.Value | LinkInput
                        }
                    }
                ) -replace ([Environment]::newline), '&lt;br/&gt;' -replace '\|', '\|' -join '|') + '|'

            $markdownLines += $markdownLine
        }                                    
    }

        
    if (  # There are a few combinations of parameters that make us want to write the -InputObject as a paragraph:
        ($ScriptBlock -and $inputObject) -or # * If -ScriptBlock and -InputObject were both provided.
        ($Heading -and $inputObject)         # * if -Heading and -InputObject were both provided
    ) {
        $markdownLines += $InputObject | LinkInput
    }


    # If we're going to render a horizontal rule (and -MarkdownTable has not been set)
    if ($HorizontalRule -and -not $MarkdownTable) {
        # add the horizontal rule at the end.
        if ($host.UI.RawUI.BufferSize.Width) {                
            $markdownLines += (([string]$HorizontalRuleCharacter) * ($Host.UI.RawUI.BufferSize.Width - 1))
        } else {
            $markdownLines += "---"
        }                        
    }
}

end {
    # Now we need to make one last pass to normalize tables
    if ($markdownLines -match '^\|') { # (that is, if we have tables to normalize).
        $maxColumnSize  = @{} # To normalize the table, we need to track the maximum size per column
        foreach ($ml in $markdownLines) {
            if ($ml -match '\^|') {
                $columnCount = 0
                foreach ($tablePart in $ml -split '(?&lt;!\\)\|' -ne '') {
                    if ((-not $maxColumnSize[$columnCount]) -or $maxColumnSize[$columnCount] -lt $tablePart.Length) {
                        $maxColumnSize[$columnCount] = [Math]::Max($tablePart.Length, 2)
                    }
                    $columnCount++
                }
            }
        }
        # One we know the maximum size per column, walk over each line
        $markdownLines = @(foreach ($ml in $markdownLines) {
            if ($ml -match '\^|') {
                $columnCount = 0
                # Recreate the line with the right amount of padding.
                '|' + (@(foreach ($tablePart in $ml -split '(?&lt;!\\)\|' -ne '') {
                    if ($tablePart -match '^[:\-]+$') {
                        if ($tablePart -match '^\:-{0,}\:$') { # If it's an alignment column, make sure to keep the alignment.
                            if ($maxColumnSize[$columnCount] -gt 2) {
                                ':' + ('-' * ($maxColumnSize[$columnCount] - 2)) + ':'
                            } else {
                                '::'
                            }
                        }
                        elseif ($tablePart -match '\:$') {
                            $tablePart.PadLeft($maxColumnSize[$columnCount], '-')
                        } 
                        elseif ($tablePart -match '^\:') {
                            $tablePart.PadRight($maxColumnSize[$columnCount], '-')
                        }
                        else {
                            $tablePart.PadRight($maxColumnSize[$columnCount], '-')
                        }
                    } else {
                        $tablePart.PadRight($maxColumnSize[$columnCount], ' ')
                    }
                    $columnCount++                                            
                }) -join '|') + '|'
            } else {
                $ml
            }
        })
    }
    $markdownLines -join [Environment]::NewLine        
}

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>FormatYAML</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Formats objects as YAML
.DESCRIPTION
    Formats an object as YAML.
.EXAMPLE
    Format-Yaml -InputObject @("a", "b", "c")
.EXAMPLE
    @{a="b";c="d";e=@{f=@('g')}} | Format-Yaml
#&gt;
param(
# The InputObject.
[Parameter(ValueFromPipeline)]
[PSObject]
$InputObject,

# If set, will make a YAML header by adding a YAML Document tag above and below output.
[Alias('YAMLDocument')]
[switch]
$YamlHeader,

[int]
$Indent = 0,

# The maximum depth of objects to include.
# Beyond this depth, an empty string will be returned.    
[int]
$Depth
)

begin {
    if (-not $Depth) { $depth = $FormatEnumerationLimit }
    $toYaml = {
        param(
        [Parameter(ValueFromPipeline,Position=0)]$Object,
        [Object]$Parent,
        [Object]$GrandParent,
        [int]$Indent = 0)
        
        begin { $n = 0; $mySelf = $myInvocation.MyCommand.ScriptBlock }
        process {
            $n++
            if ($Object -eq $null) { return }

            if ($depth) {
                $myDepth = $indent / 2
                if ($myDepth -gt $depth) {
                    return ''
                }
            }
        
            if ($Parent -and $Parent -is [Collections.IList]) {
                if ($Parent.IndexOf($Object) -gt 0) { ' ' * $Indent }
                '- '
            }
        
            #region Primitives
            if ( $Object -is [string] ) { # If it's a string
                if ($object -match '\n') { # see if it's a multline string.
                    "|" # If it is, emit the multiline indicator
                    $indent +=2
                    foreach ($l in $object -split '(?&gt;\r\n|\n)') { # and emit each line indented
                        [Environment]::NewLine
                        ' ' * $indent
                        $l
                    }
                    $indent -=2
                } elseif ("$object".Contains('*')) {
                    "'$($Object -replace "'","''")'"
                } else {
                    $object
                }
        
                if ($Parent -is [Collections.IList]) { # If the parent object was a list
                    [Environment]::NewLine # emit a newline.
                }
                return # Once the string has been emitted, return.
            }
            if ( $Object.GetType().IsPrimitive ) { # If it is a primitive type
                "$Object".ToLower()  # Emit it in lowercase.
                if ($Parent -is [Collections.IList]) {
                    [Environment]::NewLine
                }
                return
            }
            #endregion Primitives
        
            #region KVP
            if ( $Object -is [Collections.DictionaryEntry] -or $object -is [Management.Automation.PSPropertyInfo]) {
                if ($Parent -isnot [Collections.IList] -and
                    ($GrandParent -isnot [Collections.IList] -or $n -gt 1)) {
                    [Environment]::NewLine + (" " * $Indent)
                }
                if ($object.Key -and $Object.Key -is [string]) {
                    $Object.Key +": "
                } elseif ($object.Name -and $object.Name -is [string]) {
                    $Object.Name +": "
                }
            }
        
            if ( $Object -is [Collections.DictionaryEntry] -or $Object -is [Management.Automation.PSPropertyInfo]) {
                &amp; $mySelf -Object $Object.Value -Parent $Object -GrandParent $parent -Indent $Indent
                return
            }
            #endregion KVP
        
        
            #region Nested
            if ($parent -and ($Object -is [Collections.IDictionary] -or $Object  -is [PSObject])) {
                $Indent += 2
            } 
            elseif ($object -is [Collections.IList]) {
                $allPrimitive = 1
                foreach ($Obj in $Object) { 
                    $allPrimitive = $allPrimitive -band (
                        $Obj -is [string] -or 
                        $obj.GetType().IsPrimitive
                    ) 
                }
                if ($parent -and -not $allPrimitive) {
                    $Indent += 2
                }
            }
        
        
            if ( $Object -is [Collections.IDictionary] ) {
                $Object.GetEnumerator() |
                    &amp; $mySelf -Parent $Object -GrandParent $Parent -Indent $Indent
            } elseif ($Object -is [Collections.IList]) {
        
                [Environment]::NewLine + (' ' * $Indent)
        
                $Object |
                    &amp; $mySelf -Parent $Object -GrandParent $Parent -Indent $Indent
        
            } 
            elseif ($object -is [enum]) {
                $object.ToString()
            }
            elseif ($Object.PSObject.Properties) {
                $Object.psobject.properties |
                    &amp; $mySelf -Parent $Object -GrandParent $Parent -Indent $Indent
            }
        
            if ($Object -is [Collections.IDictionary] -or $Object  -is [PSCustomObject] -or $Object -is [Collections.IList]) {
                if ($Parent -is [Collections.IList]) { [Environment]::NewLine }
                $Indent -= 2;
            }
            #endregion Nested
        }                
    }
    function IndentString([string]$String,[int]$Indent) {
        @(foreach ($line in @($String -split '(?&gt;\r\n|\n)')) {
            (' ' * $indent) + $line 
        }) -join [Environment]::NewLine
    }
    $inputWasNotPiped = $PSBoundParameters.InputObject -as [bool]
    $allInputObjects  = @()
}

process {
    if ($inputWasNotPiped) {
        IndentString ('' + $(if ($YamlHeader) { '---' + [Environment]::NewLine })  + (
            (&amp; $toYaml -object $inputObject) -join '' -replace 
                "$([Environment]::NewLine * 2)", [Environment]::NewLine
        ) + $(if ($YamlHeader) { [Environment]::NewLine  + '---'})) -Indent $Indent
    } else {
        $allInputObjects += $inputObject
    }
}

end {
    if (-not $allInputObjects) { return }    
    if ($allInputObjects.Length -eq 1) {
        IndentString ('' + $(if ($YamlHeader) { '---' + [Environment]::NewLine}) + (
            (&amp; $toYaml -object $inputObject) -join '' -replace 
                "$([Environment]::NewLine * 2)", [Environment]::NewLine
        ) + $(if ($YamlHeader) { [Environment]::NewLine  + '---'})) -Indent $Indent
    } else {
        IndentString ('' + $(if ($YamlHeader) { '---' + [Environment]::NewLine})  + (
            (&amp; $toYaml -object $allInputObjects) -join '' -replace 
                "$([Environment]::NewLine * 2)", [Environment]::NewLine
        ) + $(if ($YamlHeader) { [Environment]::NewLine  + '---'})) -Indent $Indent
    }
}




                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>CurrentSite</Name>
        <GetScriptBlock>
                        param(
$this = $PSJekyll
)

$jekyllConfigFiles = Get-ChildItem -Path $pwd -Recurse -Filter _config.yml
if (-not $jekyllConfigFiles) {
    $currentFolder = Get-Item $pwd
    [PSCustomObject]@{
        PSTypeName = 'PSJekyll.Site'
        Directory = $currentFolder
        SiteName = $currentFolder.Name
    }
}

foreach ($jekyllConfigFile in $jekyllConfigFiles) {
    [PSCustomObject]@{
        PSTypeName = 'PSJekyll.Site'
        Directory = $jekyllConfigFile.Directory
        SiteName = $jekyllConfigFile.Directory.Name
    }
}





                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Template</Name>
        <GetScriptBlock>
                        [PSCustomObject]@{PSTypeName='PSJekyll.Template'}
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>PSJekyll.Site</Name>
    <Members>
      <AliasProperty>
        <Name>Drafts</Name>
        <ReferencedMemberName>Draft</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Files</Name>
        <ReferencedMemberName>File</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Includes</Name>
        <ReferencedMemberName>Include</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Layouts</Name>
        <ReferencedMemberName>Layout</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Pages</Name>
        <ReferencedMemberName>Page</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Posts</Name>
        <ReferencedMemberName>Post</ReferencedMemberName>
      </AliasProperty>
      <ScriptProperty>
        <Name>Config</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the config of the site.
.DESCRIPTION
    Gets the configuration of the Jekyll site.  
    
    This can be provided by a _config.yml file in the root of the site (and essentially marks it as a site)
#&gt;

$configFile = Join-Path $this.Directory "_config.yml"
if (Test-Path $configFile) {
    Get-Item -Path $configFile
}
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the config of the site.
.DESCRIPTION
    Gets the configuration of the Jekyll site.  
    
    This can be provided by a _config.yml file in the root of the site (and essentially marks it as a site)
#&gt;
param(
$Value
)
$configFile = Join-Path $this.Directory "_config.yml"
$valueToAdd = 
    if ($value -is [string]) {
        $value
    } 
    elseif ($value -is [IO.FileInfo]) {
        Get-Content -Path $value.FullName
    }
    else {
        &amp; $PSJekyll.FormatYAML.Script $value
    }
if (Test-Path $configFile) {    
    Set-Content -Path $configFile -Value $valueToAdd    
} else {
    New-Item -ItemType File -Path $configFile -Force -Value $valueToAdd
}
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Data</Name>
        <GetScriptBlock>
                        param()

foreach ($specialFile in $this.File -match '[\\/]_data[\\/]') {
    $specialFile.pstypenames.add("PSJekyll.DataFile")
    $specialFile
}

                    </GetScriptBlock>
        <SetScriptBlock>
                        param()

$unrolledArguments = @($args | . { process { $_ } })
$currentName = ''

filter toJsonFileName {
    $_ -replace '(?:\.json)?$', '.json'
}

foreach ($arg in $unrolledArguments) {
    if ($arg -is [Collections.IDictionary]) {
        
        foreach ($keyValue in $arg.GetEnumerator()) {            
            $targetPath = $this.Directory,"_data",($keyValue.Key | toJsonFileName) -join ([IO.Path]::DirectorySeparatorChar)
            if (-not (Test-Path $targetPath)) {
                $null = New-Item -Path $targetPath -ItemType File -Force
            }
            Set-Content -Path $targetPath -Value (
                ConvertTo-Json -Depth $FormatEnumerationLimit -InputObject $($keyValue.Value)
            )
        }
    }
    elseif ($arg -is [string]) {
        $currentName = $arg
    }
    elseif ($currentName) {
        $targetPath = $this.Directory,"_data",($currentName | toJsonFileName) -join ([IO.Path]::DirectorySeparatorChar)
        if (-not (Test-Path $targetPath)) {
            $null = New-Item -Path $targetPath -ItemType File -Force
        }
        Set-Content -Path $targetPath -Value (
            ConvertTo-Json -Depth $FormatEnumerationLimit -InputObject $arg
        )
            
    }
}

                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Domain</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the domain name of the site.
.DESCRIPTION
    Gets the domain name of the Jekyll site.  
    
    This can be provided by a CNAME file in the root of the site.
#&gt;
$cNamePath = Join-Path $this.Directory "CNAME"
if (Test-Path $cNamePath) {
    Get-Content -Path $cNamePath
}
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the domain name of the site.
.DESCRIPTION
    Sets the domain name of the Jekyll site.  
    
    This will create a CNAME file in the root of the site.
#&gt;
param([string]$cname)
$cNamePath = Join-Path $this.Directory "CNAME"
New-Item -ItemType File -Path $cNamePath -Force -Value $cname
$tryToResolveCName = try {
    [Net.Dns]::Resolve($cname)
} catch {
    Write-Warning "Could not resolve the domain name '$cname'."
}


                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Draft</Name>
        <GetScriptBlock>
                        param()

foreach ($specialFile in $this.File -match '[\\/]_drafts[\\/]') {    
    $specialFile.pstypenames.add("PSJekyll.Draft.Post")
    $specialFile.pstypenames.add("PSJekyll.Post")    
    $specialFile
}

                    </GetScriptBlock>
        <SetScriptBlock>
                        param()

$unrolledArguments = @($args | . { process { $_ } })
$currentName = ''

filter toMarkdownFileName {
    $_ -replace '(?:\.md)?$', '.md' -replace '[\s\p{P}]','-'
}

$name, $content, $metdata = $null, $null, $null

foreach ($arg in $unrolledArguments) {
    if ($arg -is [Collections.IDictionary]) {
        $metadata = $arg        
    }
    elseif ($arg -is [string] -and -not $name) {
        $Name = $arg
    }
    elseif ($arg -is [string] -and -not $content) {
        $content = $arg            
    }
}

if (-not $metadata) {
    $metadata = [Ordered]@{}
}
if (-not $metadata.date) {
    $metadata.date = [DateTime]::Now.ToString("yyyy-MM-dd HH:mm:ss K")
}
if (-not $metadata.title) {
    $metadata.title = $Name
}



Set-Content -Path (
    $this.Directory,"_drafts",($Name | toMarkdownFileName) -join ([IO.Path]::DirectorySeparatorChar) -replace '^\\'
) -Value $(
    @(
        $metadata | &amp; $psJekyll.FormatYaml.Script -YamlHeader
        $content
    ) -join [Environment]::NewLine
)
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>File</Name>
        <GetScriptBlock>
                        if ($this.Directory -and -not $this.'.FileList') {
    $this.psobject.properties.add([psnoteproperty]::new('.FileList', @($this.Directory.EnumerateFiles("*",'AllDirectories'))))    
}
return $this.'.FileList'

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Include</Name>
        <GetScriptBlock>
                        param()

foreach ($specialFile in $this.File -match '[\\/]_includes[\\/]') {
    $specialFile.pstypenames.add("PSJekyll.IncludeFile")
    $specialFile
}


                    </GetScriptBlock>
        <SetScriptBlock>
                        param()

$unrolledArguments = @($args | . { process { $_ } })

filter toFileName {
    $_ -replace '[&lt;&gt;\|\?\*:]', '-' -replace '\s','-'
}

$name, $content, $metdata = $null, $null, $null

foreach ($arg in $unrolledArguments) {
    if ($arg -is [Collections.IDictionary]) {
        $metadata = $arg        
    }
    elseif ($arg -is [string] -and -not $name) {
        $Name = $arg
    }
    elseif ($arg -is [string] -and -not $content) {
        $content = $arg            
    }
}

if (-not $metadata) {
    $metadata = [Ordered]@{}
}
if (-not $metadata.title) {
    $metadata.title = $Name
}


$destinationPath = $this.Directory,"_includes",($Name | toFileName) -join ([IO.Path]::DirectorySeparatorChar) -replace '^\\'
# Includes cannot have front matter.
$destinationContent = $content

if (-not (Test-Path $destinationPath)) {
    New-Item -Path $destinationPath -ItemType File -Value $destinationContent -Force
} else {
    Set-Content -Path $destinationPath -Value $destinationContent
}
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Layout</Name>
        <GetScriptBlock>
                        param()

foreach ($specialFile in $this.File -match '[\\/]_layouts[\\/]') {
    $specialFile.pstypenames.add("PSJekyll.LayoutFile")
    $specialFile
}


                    </GetScriptBlock>
        <SetScriptBlock>
                        param()

$unrolledArguments = @($args | . { process { $_ } })

filter toFileName {
    $_ -replace '[&lt;&gt;\|\?\*:]', '-' -replace '\s','-'
}

$name, $content, $metdata = $null, $null, $null

foreach ($arg in $unrolledArguments) {
    if ($arg -is [Collections.IDictionary]) {
        $metadata = $arg        
    }
    elseif ($arg -is [string] -and -not $name) {
        $Name = $arg
    }
    elseif ($arg -is [string] -and -not $content) {
        $content = $arg            
    }
}

if (-not $metadata) {
    $metadata = [Ordered]@{}
}
if (-not $metadata.title) {
    $metadata.title = $Name
}

if ($name -notmatch '\.[^\.]+$') {
    $Name += '.html'
}


$destinationPath = $this.Directory,"_layouts",($Name | toFileName) -join ([IO.Path]::DirectorySeparatorChar) -replace '^\\'
$destinationContent = $(
    @(
        $metadata | &amp; $psJekyll.FormatYaml.Script -YamlHeader
        $content
    ) -join [Environment]::NewLine
)
if (-not (Test-Path $destinationPath)) {
    New-Item -Path $destinationPath -ItemType File -Value $destinationContent -Force
} else {
    Set-Content -Path $destinationPath -Value $destinationContent
}

                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Page</Name>
        <GetScriptBlock>
                        foreach ($specialFile in $this.File -notmatch '[\\/]_.+?[\\/]' -match '\.(?&gt;md|markdown|html?)$') {
    $specialFile.pstypenames.add("PSJekyll.Page")    
    $specialFile
}
                    </GetScriptBlock>
        <SetScriptBlock>
                        param()

$unrolledArguments = @($args | . { process { $_ } })

filter toFileName {
    $_ -replace '[&lt;&gt;\|\?\*:]', '-' -replace '\s','-'
}

$name, $content, $metdata = $null, $null, $null

foreach ($arg in $unrolledArguments) {
    if ($arg -is [Collections.IDictionary]) {
        $metadata = $arg        
    }
    elseif ($arg -is [string] -and -not $name) {
        $Name = $arg
    }
    elseif ($arg -is [string] -and -not $content) {
        $content = $arg            
    }
}

if (-not $metadata) {
    $metadata = [Ordered]@{}
}
if (-not $metadata.title) {
    $metadata.title = $Name
}

if ($name -notmatch '\.(?&gt;md|markdown|html?)$') {
    $Name += '.md'
}

$destinationPath = $this.Directory,($Name | toFileName) -join ([IO.Path]::DirectorySeparatorChar) -replace '^\\'
$destinationContent = @(
    $metadata | &amp; $psJekyll.FormatYaml.Script -YamlHeader
    $content
) -join [Environment]::NewLine

if (-not (Test-Path $destinationPath)) {
    New-Item -Path $destinationPath -ItemType File -Value $destinationContent -Force
} else {
    Set-Content -Path $destinationPath -Value $destinationContent
}

                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Post</Name>
        <GetScriptBlock>
                        param()

foreach ($specialFile in $this.File -match '[\\/]_posts[\\/]') {    
    $specialFile.pstypenames.add("PSJekyll.Published.Post")
    $specialFile.pstypenames.add("PSJekyll.Post")    
    $specialFile
}

                    </GetScriptBlock>
        <SetScriptBlock>
                        param()

$unrolledArguments = @($args | . { process { $_ } })
$currentName = ''

filter toMarkdownFileName {
    $_ -replace '(?:\.md)?$', '.md' -replace '[\s\p{P}]','-'
}

$name, $content, $metdata = $null, $null, $null

foreach ($arg in $unrolledArguments) {
    if ($arg -is [Collections.IDictionary]) {
        $metadata = $arg        
    }
    elseif ($arg -is [string] -and -not $name) {
        $Name = $arg
    }
    elseif ($arg -is [string] -and -not $content) {
        $content = $arg            
    }
}

if (-not $metadata) {
    $metadata = [Ordered]@{}
}
if (-not $metadata.date) {
    $metadata.date = [DateTime]::Now.ToString("yyyy-MM-dd HH:mm:ss K")
}
if (-not $metadata.title) {
    $metadata.title = $Name
}



Set-Content -Path (
    $this.Directory,"_posts",($Name | toMarkdownFileName) -join ([IO.Path]::DirectorySeparatorChar) -replace '^\\'
) -Value $(
    @(
        $metadata | &amp; $psJekyll.FormatYaml.Script -YamlHeader
        $content
    ) -join [Environment]::NewLine
)
                    </SetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>PSJekyll.Template</Name>
    <Members>
      <ScriptMethod>
        <Name>Include4bitcss</Name>
        <Script>
                        param(
[string]
$PaletteName
)

if ($PaletteName) {
@"
&lt;link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/2bitdesigns/4bitcss@latest/css/$($PaletteName -replace '\.css$').css" /&gt;
"@
} else {
    @(
        "{% if site.palette %}"
        '&lt;link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/2bitdesigns/4bitcss@latest/css/{{site.palette}}.css" /&gt;'
        "{% endif %}"
    ) -join [Environment]::Newline
}



                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>IncludeGoogleAnalytics</Name>
        <Script>
                        param($AnalyticsId = 'site.analyticsId')

@"
{% if $AnalyticsId %}
&lt;!-- Google tag (gtag.js) --&gt;
&lt;script async src="https://www.googletagmanager.com/gtag/js?id={{$AnalyticsId}}"&gt;&lt;/script&gt;
&lt;script&gt;
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', '{{$AnalyticsId}}');
&lt;/script&gt;
{% endif %}
"@
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>IncludeGoogleFont</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Includes a Google Font.
.DESCRIPTION
    Includes a Google Font in the site.
    
    This will add a link to the Google Font.  It should be located in the head of the site.
#&gt;

param(
# The name of the font to include.
[string]
$FontName
)
if ($FontName) {
    "&lt;link href='https://fonts.googleapis.com/css?family=$fontName' rel='stylesheet'&gt;"
} else {
    @(
        "{% if site.googleFont %}"
            "&lt;link href='https://fonts.googleapis.com/css?family={{site.googleFont}}' rel='stylesheet'&gt;"
            "&lt;style type='text/css'&gt;body { font-family: '{{site.googleFont}}',sans-serif } &lt;/style&gt;"
        "{% endif %}"
    ) -join [Environment]::Newline
}


                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>IncludeImportMap</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Includes an import map.
.DESCRIPTION
    Includes an import map in the site.
    
    This will add a script tag with the import map.  It should be located in the head of the site.

    If the importmap parameter is provided, it will be used.  Otherwise, the site.data.imports will be used.
#&gt;
param(
$ImportMap
)

if ($ImportMap) {
"&lt;script type='importmap'&gt;"
[Ordered]@{
    imports = $ImportMap
} | ConvertTo-Json -Depth 3
"&lt;/script&gt;"
} else {
@'
{% if site.data.imports %}
&lt;script type="importmap"&gt;
    {
        "imports": {
            {% for eachImport in site.data.imports %}
                "{{eachImport[0]}}": "{{eachImport[1]}}"{% unless forloop.last %},
                {% endunless %}
            {% endfor %}
        }
    }    
&lt;/script&gt;
    
{% endif %}

'@    
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>IncludeOpenGraph</Name>
        <Script>
                        param()

@'
&lt;meta content="{{ site.title }}" property="og:site_name" /&gt;
{% if page.title %}
&lt;meta content="{{ page.title }}" property="og:title" /&gt;
{% elsif page.stylesheet %}
&lt;meta content="{{ page.stylesheet }}" property="og:title" /&gt;
{% else %}
&lt;meta content="{{ site.title }}" property="og:title" /&gt;
{% endif %}
{% if page.type %}
&lt;meta content="{{ page.type }}" property="og:type" /&gt;
{% else %}
&lt;meta content="website" property="og:type" /&gt;
{% endif %}
{% if page.description %}
&lt;meta content="{{ page.description }}" property="og:description" /&gt;
&lt;meta name="description" content="{{ page.description }}" /&gt;
&lt;meta name="twitter:description" content="{{ page.description }}" /&gt;
{% elsif content %}

&lt;meta property="og:description" content="{{ content | strip_html | truncatewords: 20 }}" /&gt;
&lt;meta name="description" content="{{ content | strip_html | truncatewords: 20 }}" /&gt;
&lt;meta name="twitter:description" content="{{ content | strip_html | truncatewords: 20 }}" /&gt;

{% elsif site.description %}
&lt;meta content="{{ site.description }}" property="og:description" /&gt;
&lt;meta name="description" content="{{ site.description }}" /&gt;
&lt;meta name="twitter:description" content="{{ site.description }}" /&gt;
{% endif %}
{% if page.date %}
    &lt;meta content="{{ page.date | date_to_xmlschema }}" property="article:published_time" /&gt;
{% endif %}
{% if page.url %}
    &lt;meta content="{{ site.url }}{{ page.url }}" property="og:url" /&gt;
    &lt;meta name="twitter:url" content="{{ site.url }}{{ page.url }}" /&gt;
    &lt;meta name="twitter:domain" content="{{ site.url }}" /&gt;
{% endif %}

{% if page.image %}
    &lt;meta content="/{{ page.image }}" property="og:image" /&gt;
    &lt;meta name="twitter:image" content="{{ site.url }}/{{ page.image }}" /&gt;
    &lt;meta name="twitter:image:src" content="{{ site.url }}/{{ page.image }}"  /&gt;
{% elsif site.image %}
    &lt;meta content="{{ site.url }}/{{ site.image }}" property="og:image" /&gt;
    &lt;meta name="twitter:image" content="{{ site.url }}/{{ site.image }}" /&gt;
    &lt;meta name="twitter:image:src" content="{{ site.url }}/{{ site.image }}" /&gt;
{% endif %}
'@


                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>LayoutDefault</Name>
        <Script>
                        
@"
&lt;!DOCTYPE html&gt;
&lt;html lang="{{ site.lang | default: "en" }}"&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
    {% include GoogleAnalytics.html %}
    {% include ImportMap.html %}
    {% include OpenGraph.html %}
    {% include GoogleFont.html %}
    {% include 4bitcss.html %}
&lt;/head&gt;
&lt;body&gt;
{{content}}
&lt;/body&gt;
"@
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>MinGemFile</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Minimal Gemfile for Jekyll projects.
.DESCRIPTION
    Generates the minimal Gemfile for Jekyll projects.
#&gt;
param()

"source 'https://rubygems.org'"
"gem 'jekyll'"

                    </Script>
      </ScriptMethod>
    </Members>
  </Type>
</Types>